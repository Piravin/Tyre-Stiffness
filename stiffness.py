# -*- coding: utf-8 -*-
"""Untitled14.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zzRSqcOOz_mWsGQUwdSqWT1-FRl_UbxI

#Important Instructions

Click on the file icon and wait till you see an upload option 
Then upload the video named as "capture.mp4"
The most important aspect of getting an accurate result is the stability of the video . So do not record the video while holding the device in hand . Its better to place the camera on a table or a tripod.

To run the script click the run button on the top left cornor of the celll (a number appears if not hovered over the cell) 

The result will be displayed below the cell in a graph and a csv file will also be available in the files section
"""

import cv2
import os
import csv
import time
import matplotlib.pyplot as plt

def main():
    if os.path.isfile('result.csv'):
        os.remove('result.csv')
    cap = cv2.VideoCapture('capture.mp4')
    filename = 'result.mp4'
    fps = 24.0
    res = '720p'
    def change_res(cap, width, height):
        cap.set(3, width)
        cap.set(4, height)

    STD_DIMENSIONS = {
        "480p": (640,480),
        "720p":(1280,720),
        "1080p":(1920,1080),
        "4k": (3840,2160),
    }

    VIDEO_TYPE = {
        "avi": cv2.VideoWriter_fourcc(*'XVID'),
        "mp4": cv2.VideoWriter_fourcc(*'MPEG')
    }

    def get_video_type(filename):
        filename, ext = os.path.splitext(filename)
        if ext in VIDEO_TYPE:
            return VIDEO_TYPE[ext]
        return VIDEO_TYPE['avi']

    def get_dims( cap, res = '1080p'):
        width, height = STD_DIMENSIONS['480p']
        if res in STD_DIMENSIONS:
            width, height = STD_DIMENSIONS[res]
        change_res(cap, width, height)
        return (width, height)

    dims = get_dims(cap, res = res)
    video_type_cv2 = get_video_type(filename)

    ret, frame1 = cap.read()
    # frame1 = cv2.rotate(frame1,cv2.ROTATE_90_CLOCKWISE)
    ret, frame2 = cap.read()
    # frame2 = cv2.rotate(frame2,cv2.ROTATE_90_CLOCKWISE)
    start_time = time.time()

    while cap.isOpened() and ret:
        diff = cv2.absdiff(frame1, frame2)
        grey  = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)
        blur = cv2.GaussianBlur(grey, (5,5), 0)
        _, thresh = cv2.threshold(blur, 50, 255, cv2.THRESH_BINARY)
        dilated = cv2.dilate(thresh, None, iterations = 7)
        contours, _ = cv2.findContours(dilated,cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

        for contour in contours:
            cur_time = time.time() - start_time

            (x,y,w,h) = cv2.boundingRect(contour)

            if cv2.contourArea(contour) < 1000: #10000:
                continue
            cv2.rectangle(frame1, (x,y), (x+w,y+h), (0,0,0), 2)
            cv2.putText(frame1,f"X : {x+w/2}  Y : {y+h/2}", (50,100), cv2.FONT_HERSHEY_DUPLEX, 1, (0,0,255), 2)
            
            with open('result.csv','a') as result:
                writer = csv.writer(result)
                writer.writerow([cur_time,y])
        # cv2.drawContours(frame1, contours, -1, (0,255,0), 2)
        # cv2.imshow("Feed",frame1)

        frame1 = frame2
        ret, frame2 = cap.read()
        frame2 = cv2.rotate(frame2,cv2.ROTATE_90_CLOCKWISE)


        if cv2.waitKey(40) == 27:
            break

    cv2.destroyAllWindows()

    X, Y = [],[]

    with open('result.csv','r') as f:
        plots = csv.reader(f,delimiter=',')
        for row in plots:
            if row:
                X.append(float(row[0]))
                Y.append(float(row[1]))
    plt.figure('Result')
    plt.plot(X,Y, label = "Altitude vs Time")
    plt.xlabel('Time')
    plt.ylabel('Altitude')
    plt.title('Altitude vs Time')
    plt.legend()
    plt.show()

if __name__ == '__main__':
    main()